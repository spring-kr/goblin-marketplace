<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🏆 도깨비마을장터 v11.5 - 완전체 AI 상담 시스템</title>
    
    <!-- Vercel Analytics - 방문자 및 페이지 조회수 추적 -->
    <script defer src="https://analytics.eu.vercel-insights.com/script.js"></script>
    
    <!-- Socket.IO -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    
    <!-- CSS 스타일 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .header {
            background: rgba(255,255,255,0.95);
            padding: 1rem 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left h1 {
            color: #5a67d8;
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .header-left .subtitle {
            color: #666;
            font-size: 1rem;
        }

        .header-right {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .dashboard-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dashboard-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            text-decoration: none;
        }

        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 500px;
            gap: 1rem;
            padding: 1rem;
            max-width: 1800px;
            margin: 0 auto;
            height: calc(100vh - 120px);
        }

        /* 오른쪽 아바타 대시보드 */
        .avatar-dashboard {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .avatar-dashboard h3 {
            color: #5a67d8;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            text-align: center;
        }

        #avatar-container {
            width: 100%;
            height: 900px;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        .avatar-info {
            background: rgba(90, 103, 216, 0.1);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .avatar-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .stat-item {
            background: rgba(255,255,255,0.8);
            padding: 0.5rem;
            border-radius: 5px;
            text-align: center;
            font-size: 0.85rem;
        }

        .emotion-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .emotion-btn {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 80px;
        }

        .emotion-btn.happy { background: #e8f5e8; color: #27ae60; }
        .emotion-btn.sad { background: #f8e8e8; color: #e74c3c; }
        .emotion-btn.excited { background: #fff3e0; color: #f39c12; }
        .emotion-btn.neutral { background: #f8f9fa; color: #6c757d; }
        .emotion-btn.thinking { background: #e3f2fd; color: #2196f3; }

        .emotion-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .memory-display {
            background: rgba(155, 89, 182, 0.1);
            border-radius: 8px;
            padding: 0.8rem;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .avatar-chat {
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .avatar-chat input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .avatar-chat button {
            width: 100%;
            padding: 0.5rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        /* 채팅 메시지 스타일 */
        .message {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 8px;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.4;
            font-size: 0.85rem;
        }

        .user-message {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            text-align: right;
            margin-left: 20%;
        }

        .avatar-message {
            background: #f3e5f5;
            border: 1px solid #e1bee7;
            text-align: left;
            margin-right: 20%;
        }

        .avatar-chat button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        /* 도깨비 패널 */
        .goblin-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            overflow-y: auto;
        }

        .goblin-panel h3 {
            color: #5a67d8;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .goblin-card {
            background: #f8f9ff;
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 0.8rem;
            margin-bottom: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .goblin-card:hover {
            border-color: #5a67d8;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(90,103,216,0.2);
        }

        .goblin-card.selected {
            border-color: #5a67d8;
            background: #eef2ff;
        }

        .goblin-name {
            font-weight: bold;
            color: #5a67d8;
            margin-bottom: 0.3rem;
        }

        .goblin-specialty {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 0.3rem;
        }

        .goblin-personality {
            font-size: 0.8rem;
            color: #888;
            font-style: italic;
            margin-bottom: 0.3rem;
        }

        .goblin-price {
            font-size: 0.9rem;
            font-weight: bold;
            color: #e53e3e;
            background: rgba(229, 62, 62, 0.1);
            padding: 0.2rem 0.5rem;
            border-radius: 0.3rem;
            text-align: center;
        }

        .goblin-price:contains('무료') {
            color: #38a169;
            background: rgba(56, 161, 105, 0.1);
        }

        /* 채팅 영역 */
        .chat-container {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .chat-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            background: #5a67d8;
            color: white;
            border-radius: 15px 15px 0 0;
        }

        .chat-mode-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .mode-btn {
            padding: 0.3rem 0.8rem;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: rgba(255,255,255,0.9);
            color: #5a67d8;
        }

        .chat-messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            max-height: 400px;
        }

        .message {
            margin-bottom: 1rem;
            animation: fadeInUp 0.3s ease;
        }

        .message.user {
            text-align: right;
        }

        .message.goblin {
            text-align: left;
        }

        .message-bubble {
            display: inline-block;
            max-width: 80%;
            padding: 0.8rem 1.2rem;
            border-radius: 20px;
            line-height: 1.4;
        }

        .message.user .message-bubble {
            background: #5a67d8;
            color: white;
        }

        .message.goblin .message-bubble {
            background: #f1f5f9;
            color: #334155;
            border: 1px solid #e2e8f0;
        }

        .message-time {
            font-size: 0.7rem;
            color: #888;
            margin-top: 0.3rem;
        }

        .chat-input-area {
            padding: 1rem 1.5rem;
            border-top: 1px solid #e2e8f0;
            background: #f8fafc;
            border-radius: 0 0 15px 15px;
        }

        .input-container {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            padding: 0.8rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 25px;
            font-size: 1rem;
            resize: none;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .chat-input:focus {
            border-color: #5a67d8;
        }

        .send-btn {
            padding: 0.8rem 1.5rem;
            background: #5a67d8;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .send-btn:hover {
            background: #4c51bf;
            transform: translateY(-1px);
        }

        .send-btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        /* 📄 파일 업로드 스타일 */
        .file-upload-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 8px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-upload-btn:hover {
            background: #5a67d8;
            transform: scale(1.1);
        }

        .file-upload-area {
            background: rgba(255,255,255,0.98);
            border-radius: 15px;
            margin: 1rem 0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
            animation: slideDown 0.3s ease;
        }

        .upload-container {
            padding: 1.5rem;
        }

        .upload-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .upload-header h4 {
            margin: 0;
            color: #4a5568;
            font-size: 1.1rem;
        }

        .close-upload-btn {
            background: none;
            border: none;
            color: #a0aec0;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .close-upload-btn:hover {
            background: #fed7d7;
            color: #e53e3e;
        }

        .file-drop-zone {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(247, 250, 252, 0.5);
        }

        .file-drop-zone:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .file-drop-zone.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .drop-message {
            color: #4a5568;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .file-info {
            color: #718096;
            font-size: 0.9rem;
        }

        .upload-progress {
            margin-top: 1rem;
        }

        .progress-bar {
            background: #e2e8f0;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            color: #4a5568;
            font-size: 0.9rem;
            text-align: center;
        }

        .analysis-result {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(247, 250, 252, 0.8);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .analysis-result h5 {
            margin: 0 0 0.5rem 0;
            color: #2d3748;
        }

        .analysis-summary {
            margin-bottom: 1rem;
            color: #4a5568;
            line-height: 1.5;
        }

        .analysis-keywords {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .keyword-tag {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.2);
        }

        .analysis-result {
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .analysis-result h4 {
            color: #2d3748;
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .analysis-result h4 i {
            color: #667eea;
        }

        .file-info {
            background: rgba(255, 255, 255, 0.6);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border-left: 3px solid #667eea;
        }

        .file-info strong {
            color: #2d3748;
        }

        .analysis-summary {
            background: rgba(255, 255, 255, 0.8);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border-left: 3px solid #48bb78;
        }

        .analysis-summary strong {
            color: #2d3748;
            display: block;
            margin-bottom: 0.5rem;
        }

        .analysis-summary p {
            color: #4a5568;
            line-height: 1.6;
            margin: 0;
        }

        .analysis-content {
            color: #4a5568;
            line-height: 1.6;
            margin: 0;
            white-space: pre-line;
            word-wrap: break-word;
            max-width: 100%;
        }

        .keywords {
            background: rgba(255, 255, 255, 0.6);
            padding: 1rem;
            border-radius: 8px;
            border-left: 3px solid #ed8936;
        }

        .keywords strong {
            color: #2d3748;
            display: block;
            margin-bottom: 0.75rem;
        }

        .error-message {
            background: linear-gradient(135deg, #fed7d7, #feb2b2);
            color: #742a2a;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #e53e3e;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 2px 4px rgba(229, 62, 62, 0.1);
        }

        .error-message i {
            color: #e53e3e;
            font-size: 1.1rem;
        }

        .insights {
            background: rgba(255, 255, 255, 0.6);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border-left: 3px solid #38a169;
        }

        .insights strong {
            color: #2d3748;
            display: block;
            margin-bottom: 0.5rem;
        }

        .insights ul {
            margin: 0;
            padding-left: 1.5rem;
        }

        .insights li {
            color: #4a5568;
            line-height: 1.5;
            margin-bottom: 0.25rem;
        }

        .expert-analysis {
            background: rgba(255, 255, 255, 0.8);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border-left: 3px solid #805ad5;
        }

        .expert-analysis strong {
            color: #2d3748;
            display: block;
            margin-bottom: 0.5rem;
        }

        .expert-analysis p {
            color: #4a5568;
            line-height: 1.6;
            margin: 0;
        }

        .keyword-tag {
            background: #667eea;
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.8rem;
        }

        .analysis-insights {
            margin-top: 1rem;
        }

        .insight-item {
            margin-bottom: 0.5rem;
            color: #4a5568;
            font-size: 0.9rem;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 성능 패널 */
        .performance-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            overflow-y: auto;
        }

        .performance-panel h3 {
            color: #5a67d8;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #5a67d8;
            margin-bottom: 0.3rem;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
        }

        .team-mode-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e2e8f0;
        }

        .team-btn {
            width: 100%;
            padding: 0.8rem;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
        }

        .team-btn:hover {
            background: #059669;
            transform: translateY(-1px);
        }

        .feedback-section {
            margin-top: 1rem;
            padding: 1rem;
            background: #fff7ed;
            border-radius: 10px;
            border: 1px solid #fed7aa;
        }

        .rating-stars {
            display: flex;
            gap: 0.3rem;
            justify-content: center;
            margin: 0.5rem 0;
        }

        .star {
            font-size: 1.5rem;
            cursor: pointer;
            color: #d1d5db;
            transition: color 0.2s ease;
        }

        .star.active {
            color: #fbbf24;
        }

        .feedback-btn {
            width: 100%;
            padding: 0.5rem;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 0.5rem;
            transition: all 0.3s ease;
        }

        .feedback-btn:hover {
            background: #d97706;
        }

        /* 로딩 애니메이션 */
        .loading {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #f3f4f6;
            border-top: 2px solid #5a67d8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 반응형 디자인 */
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
                height: auto;
            }
            
            .goblin-panel, .performance-panel {
                max-height: 200px;
            }
        }

        /* 알림 토스트 */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.error {
            background: #ef4444;
        }
    </style>
</head>

<body>
    <!-- 헤더 -->
    <div class="header">
        <div class="header-left">
            <h1>🏆 도깨비마을장터 v11.5</h1>
            <p class="subtitle">32명 전문가 × 27명 도깨비 × 실시간 학습 = 완전체 AI 상담 시스템</p>
        </div>
        <div class="header-right">
            <a href="/dashboard" class="dashboard-btn">
                🎮 3D 실시간 대시보드
            </a>
        </div>
    </div>

    <!-- 메인 컨테이너 -->
    <div class="main-container">
        <!-- 도깨비 선택 패널 -->
        <div class="goblin-panel">
            <h3>🧙‍♂️ 도깨비 선택</h3>
            <div id="goblin-list">
                <!-- 도깨비 목록이 여기에 동적으로 추가됩니다 -->
            </div>
            
            <div class="team-mode-section">
                <h4>🤝 팀 협업 모드</h4>
                <button class="team-btn" onclick="startTeamMode()">선택된 도깨비들과 협업</button>
                <button class="team-btn" onclick="goToPayment()" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); margin-left: 10px;">💳 유료 상담 신청</button>
                <div id="selected-goblins">
                    <small>선택된 도깨비: <span id="selected-count">0</span>명</small>
                </div>
            </div>
        </div>

        <!-- 채팅 영역 -->
        <div class="chat-container">
            <div class="chat-header">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 id="chat-title">도깨비를 선택해주세요</h3>
                    <button id="new-chat-btn" onclick="startNewChatSession()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 0.4rem 0.8rem; border-radius: 15px; cursor: pointer; font-size: 0.8rem; display: none;">
                        🔄 새 대화
                    </button>
                </div>
                <div class="chat-mode-selector">
                    <div class="mode-btn active" data-mode="deep">심화탐구</div>
                    <div class="mode-btn" data-mode="creative">창의협업</div>
                </div>
            </div>
            
            <div class="chat-messages" id="chat-messages">
                <div class="message goblin">
                    <div class="message-bubble" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 0.8rem 1.2rem;">
                        <div style="text-align: center;">
                            <div style="font-size: 1rem; margin-bottom: 0.2rem;">🎭 <strong>도깨비마을장터에 오신 것을 환영합니다!</strong></div>
                            <div style="font-size: 0.85rem; opacity: 0.9;">
                                🧙‍♂️ 32명의 전문가 도깨비 · 💡 심화탐구/창의협업 모드
                            </div>
                        </div>
                    </div>
                    <div class="message-time" style="text-align: center; color: #667eea; font-weight: 500;">🏰 도깨비마을장터 v11.5</div>
                </div>
            </div>
            
            <!-- 📄 파일 업로드 영역 -->
            <div class="file-upload-area" id="file-upload-area" style="display: none;">
                <div class="upload-container">
                    <div class="upload-header">
                        <h4>📄 파일 분석</h4>
                        <button class="close-upload-btn" onclick="toggleFileUpload()">✕</button>
                    </div>
                    <div class="upload-content">
                        <div class="file-drop-zone" id="file-drop-zone">
                            <div class="drop-text">
                                <div class="upload-icon">📁</div>
                                <div class="drop-message">파일을 드래그하거나 클릭해서 업로드하세요</div>
                                <div class="file-info">PDF, Word, Excel, PowerPoint, 이미지 지원 (최대 16MB)</div>
                            </div>
                            <input type="file" id="file-input" accept=".pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.csv,.png,.jpg,.jpeg,.gif,.bmp" style="display: none;" multiple="false">
                        </div>
                        <div class="upload-progress" id="upload-progress" style="display: none;">
                            <div class="progress-bar">
                                <div class="progress-fill" id="progress-fill"></div>
                            </div>
                            <div class="progress-text" id="progress-text">업로드 중...</div>
                        </div>
                        <div class="analysis-result" id="analysis-result" style="display: none;"></div>
                    </div>
                </div>
            </div>
            
            <div class="chat-input-area">
                <div class="input-container">
                    <button id="file-upload-btn" class="file-upload-btn" onclick="toggleFileUpload()" title="파일 분석">
                        📄
                    </button>
                    <textarea 
                        id="chat-input" 
                        class="chat-input" 
                        placeholder="도깨비에게 메시지를 입력하세요..." 
                        rows="2"
                        disabled
                    ></textarea>
                    <button id="send-btn" class="send-btn" onclick="sendMessage()" disabled>
                        전송
                    </button>
                </div>
            </div>
        </div>

        <!-- 실시간 아바타 대시보드 -->
        <div class="avatar-dashboard">
            <h3>� 실시간 아바타 대시보드</h3>
            
            <!-- 3D 아바타 컨테이너 -->
            <div id="avatar-container">
            </div>
            <!-- 감정 제어 -->
            <div class="emotion-controls">
                <button class="emotion-btn happy" onclick="setAvatarEmotion('happy')">😊 기쁨</button>
                <button class="emotion-btn neutral" onclick="setAvatarEmotion('neutral')">😐 중립</button>
                <button class="emotion-btn excited" onclick="setAvatarEmotion('excited')">🤩 흥분</button>
                <button class="emotion-btn thinking" onclick="setAvatarEmotion('thinking')">🤔 생각</button>
                <button class="emotion-btn sad" onclick="setAvatarEmotion('sad')">😢 슬픔</button>
            </div>
            
            <!-- 아바타와 직접 대화 -->
            <div class="avatar-chat">
                <div style="font-weight: bold; margin-bottom: 0.5rem; color: #5a67d8;">💬 아바타와 대화</div>
                <div id="avatar-messages" style="height: 200px; overflow-y: auto; border: 1px solid #e2e8f0; padding: 0.5rem; margin-bottom: 0.5rem; background: white; border-radius: 4px;"></div>
                <input type="text" id="avatar-chat-input" placeholder="아바타에게 직접 말해보세요..." onkeypress="handleAvatarKeyPress(event)">
                <button onclick="sendAvatarMessage()">전송</button>
            </div>
        </div>
    </div>

    <!-- Three.js for 3D Avatar -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- JavaScript -->
    <script>
        // 전역 변수
        let socket;
        let selectedGoblins = new Set();
        let currentConversationId = null;
        let currentMode = 'deep';
        let isTeamMode = false;
        let lastMessageId = null;
        let selectedRating = 0;

        // 세션 기반 conversation_id 관리
        function getSessionConversationId() {
            const currentGoblinId = Array.from(selectedGoblins)[0];
            if (!currentGoblinId) return null;
            
            const sessionKey = `conversation_${currentGoblinId}`;
            let conversationId = sessionStorage.getItem(sessionKey);
            
            if (!conversationId) {
                // 새 세션 생성
                conversationId = `session_${currentGoblinId}_${Date.now()}`;
                sessionStorage.setItem(sessionKey, conversationId);
                console.log(`🆕 새 세션 시작: ${conversationId}`);
            } else {
                console.log(`🔄 기존 세션 계속: ${conversationId}`);
            }
            
            return conversationId;
        }

        // 새로운 대화 세션 시작 (다른 도깨비 선택시)
        function startNewSession() {
            const currentGoblinId = Array.from(selectedGoblins)[0];
            if (!currentGoblinId) return;
            
            const sessionKey = `conversation_${currentGoblinId}`;
            const conversationId = `session_${currentGoblinId}_${Date.now()}`;
            sessionStorage.setItem(sessionKey, conversationId);
            currentConversationId = conversationId;
            
            console.log(`🆕 새 대화 세션 시작: ${conversationId}`);
            
            // 채팅 화면 초기화
            const messagesContainer = document.getElementById('chat-messages');
            if (messagesContainer) {
                messagesContainer.innerHTML = '';
            }
        }

        // 사용자가 수동으로 새 대화 시작
        function startNewChatSession() {
            const currentGoblinId = Array.from(selectedGoblins)[0];
            if (!currentGoblinId) {
                showToast('먼저 도깨비를 선택해주세요', 'error');
                return;
            }
            
            // 확인 대화상자
            if (confirm('새로운 대화를 시작하시겠습니까? 이전 대화 내용은 초기화됩니다.')) {
                startNewSession();
                showToast('새로운 대화가 시작되었습니다! 🆕');
            }
        }

        // Socket.IO 연결 (임시 비활성화)
        function initSocket() {
            console.log('Socket.IO 연결 비활성화됨 - 시뮬레이션 모드');
            // socket = io();
            
            // socket.on('connect', function() {
            //     console.log('서버에 연결되었습니다');
            //     showToast('도깨비마을장터에 연결되었습니다! 🎉');
            // });
            
            // socket.on('connected', function(data) {
            //     console.log('연결 확인:', data);
            // });
            
            // socket.on('chat_response', function(data) {
            //     handleChatResponse(data);
            // });
            
            // socket.on('team_response', function(data) {
            //     handleTeamResponse(data);
            // });
            
            // socket.on('feedback_result', function(data) {
            //     handleFeedbackResult(data);
            // });
            
            // socket.on('performance_update', function(data) {
            //     updatePerformanceStats(data);
            // });
            
            // socket.on('disconnect', function() {
            //     console.log('서버 연결이 끊어졌습니다');
            //     showToast('연결이 끊어졌습니다', 'error');
            // });
        }

        // 도깨비 목록 로드
        async function loadGoblins() {
            try {
                const response = await fetch('/api/goblins');
                const data = await response.json();
                
                if (data.status === 'success') {
                    displayGoblins(data.experts);
                } else {
                    console.error('도깨비 목록 로드 실패:', data.error);
                }
            } catch (error) {
                console.error('도깨비 목록 로드 오류:', error);
            }
        }

        // 도깨비 목록 표시
        function displayGoblins(experts) {
            const goblinList = document.getElementById('goblin-list');
            goblinList.innerHTML = '';
            
            experts.forEach((expert) => {
                const goblinCard = document.createElement('div');
                goblinCard.className = 'goblin-card';
                goblinCard.dataset.goblinId = expert.id;
                
                // 무료/유료 표시
                const priceDisplay = expert.free ? '🆓 무료' : `₩${expert.price.toLocaleString()}`;
                
                goblinCard.innerHTML = `
                    <div class="goblin-name">${expert.name}</div>
                    <div class="goblin-specialty">${expert.specialty}</div>
                    <div class="goblin-personality">${expert.personality}</div>
                    <div class="goblin-price">${priceDisplay}</div>
                `;
                
                goblinCard.onclick = () => selectGoblin(expert.id, expert);
                goblinList.appendChild(goblinCard);
            });
        }

        // 도깨비 선택
        function selectGoblin(goblinId, goblinInfo) {
            // 단일 모드일 때
            if (!isTeamMode) {
                // 기존 선택 해제
                document.querySelectorAll('.goblin-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                // 새로운 선택
                document.querySelector(`[data-goblin-id="${goblinId}"]`).classList.add('selected');
                
                // 이전 도깨비와 다른 경우에만 새 세션 시작
                const previousGoblin = Array.from(selectedGoblins)[0];
                selectedGoblins.clear();
                selectedGoblins.add(goblinId);
                
                if (previousGoblin !== goblinId) {
                    // 다른 도깨비 선택시 새 세션 시작
                    startNewSession();
                    console.log(`🔄 도깨비 변경: ${previousGoblin} → ${goblinId}`);
                } else {
                    // 같은 도깨비면 기존 세션 유지
                    currentConversationId = getSessionConversationId();
                }
                
                // 채팅 제목 업데이트
                document.getElementById('chat-title').textContent = `💬 ${goblinInfo.name}과 대화 중`;
                
                // 새 대화 버튼 표시
                document.getElementById('new-chat-btn').style.display = 'block';
                
                // 채팅 입력 활성화
                document.getElementById('chat-input').disabled = false;
                document.getElementById('send-btn').disabled = false;
                
            } else {
                // 팀 모드일 때
                const card = document.querySelector(`[data-goblin-id="${goblinId}"]`);
                if (selectedGoblins.has(goblinId)) {
                    selectedGoblins.delete(goblinId);
                    card.classList.remove('selected');
                } else if (selectedGoblins.size < 5) { // 최대 5명
                    selectedGoblins.add(goblinId);
                    card.classList.add('selected');
                }
                
                updateSelectedCount();
            }
        }

        // 선택된 도깨비 수 업데이트
        function updateSelectedCount() {
            document.getElementById('selected-count').textContent = selectedGoblins.size;
        }

        // 팀 모드 시작
        function startTeamMode() {
            if (selectedGoblins.size === 0) {
                showToast('도깨비를 먼저 선택해주세요', 'error');
                return;
            }
            
            isTeamMode = true;
            const goblinNames = Array.from(selectedGoblins).map(id => {
                const card = document.querySelector(`[data-goblin-id="${id}"]`);
                return card.querySelector('.goblin-name').textContent;
            }).join(', ');
            
            document.getElementById('chat-title').textContent = `🤝 팀 협업: ${goblinNames}`;
            document.getElementById('chat-input').disabled = false;
            document.getElementById('send-btn').disabled = false;
            
            currentConversationId = null;
        }

        // 결제 페이지로 이동
        function goToPayment() {
            window.open('/payment', '_blank');
        }

        // 대화 모드 변경
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;
            };
        });

        // 메시지 전송
        function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            
            if (!message) return;
            if (selectedGoblins.size === 0) {
                showToast('도깨비를 먼저 선택해주세요', 'error');
                return;
            }
            
            // 사용자 메시지 표시
            addMessage('user', message);
            
            // 로딩 메시지 표시
            const loadingId = addLoadingMessage();
            
            // 입력 비활성화
            input.disabled = true;
            document.getElementById('send-btn').disabled = true;
            
            if (isTeamMode && selectedGoblins.size > 1) {
                // 팀 채팅 (시뮬레이션)
                console.log('팀 채팅 시뮬레이션:', {
                    goblin_ids: Array.from(selectedGoblins),
                    message: message,
                    conversation_id: currentConversationId
                });
                
                // 시뮬레이션 응답
                setTimeout(() => {
                    simulateTeamResponse(message, Array.from(selectedGoblins));
                }, 1000);
                
            } else {
                // 개별 채팅 (시뮬레이션)
                const goblinId = Array.from(selectedGoblins)[0];
                console.log('개별 채팅 시뮬레이션:', {
                    goblin_id: goblinId,
                    message: message,
                    conversation_id: currentConversationId,
                    mode: currentMode
                });
                
                // 고급 AI API 호출
                setTimeout(() => {
                    callAdvancedAI(message, goblinId);
                }, 1000);
            }
            
            input.value = '';
        }

        // 채팅 응답 처리
        function handleChatResponse(data) {
            removeLoadingMessage();
            
            if (data && data.success && data.result) {
                const result = data.result;
                if (result.response) {
                    addMessage('goblin', result.response);
                    
                    currentConversationId = result.conversation_id || 'sim_' + Date.now();
                    lastMessageId = 'msg_' + Date.now();
                    
                    // 피드백 버튼 활성화
                    const feedbackBtn = document.querySelector('.feedback-btn');
                    if (feedbackBtn) {
                        feedbackBtn.disabled = false;
                    }
                    
                    // 전문가 정보 표시 (선택적)
                    if (result.selected_experts) {
                        addSystemMessage(`🎯 참여 전문가: ${result.selected_experts.join(', ')}`);
                    }
                } else {
                    addMessage('goblin', '❌ 응답 데이터가 올바르지 않습니다.');
                }
            } else {
                const errorMsg = data && data.error ? data.error : '알 수 없는 오류가 발생했습니다.';
                addMessage('goblin', `❌ 오류가 발생했습니다: ${errorMsg}`);
            }
            
            // 입력 다시 활성화
            document.getElementById('chat-input').disabled = false;
            document.getElementById('send-btn').disabled = false;
        }

        // 팀 응답 처리
        function handleTeamResponse(data) {
            removeLoadingMessage();
            
            if (data.success) {
                const result = data.result;
                addMessage('goblin', result.team_synthesis);
                
                currentConversationId = result.conversation_id;
                lastMessageId = 'msg_' + Date.now();
                
                // 피드백 버튼 활성화
                document.querySelector('.feedback-btn').disabled = false;
            } else {
                addMessage('goblin', `❌ 팀 협업 오류: ${data.error}`);
            }
            
            // 입력 다시 활성화
            document.getElementById('chat-input').disabled = false;
            document.getElementById('send-btn').disabled = false;
        }

        // 메시지 추가
        function addMessage(type, content) {
            const messagesContainer = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const now = new Date();
            const timeString = now.toLocaleTimeString('ko-KR', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            messageDiv.innerHTML = `
                <div class="message-bubble">${content}</div>
                <div class="message-time">${timeString}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // 시스템 메시지 추가
        function addSystemMessage(content) {
            const messagesContainer = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message goblin';
            messageDiv.style.opacity = '0.7';
            
            messageDiv.innerHTML = `
                <div class="message-bubble" style="background: #f0f9ff; border-color: #0ea5e9; font-size: 0.9em;">
                    ${content}
                </div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // 로딩 메시지 추가
        function addLoadingMessage() {
            const messagesContainer = document.getElementById('chat-messages');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'message goblin loading-message';
            loadingDiv.id = 'loading-message';
            
            loadingDiv.innerHTML = `
                <div class="message-bubble">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        도깨비가 생각 중입니다...
                    </div>
                </div>
            `;
            
            messagesContainer.appendChild(loadingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            return 'loading-message';
        }

        // 로딩 메시지 제거
        function removeLoadingMessage() {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                loadingMessage.remove();
            }
        }

        // 파일 업로드 토글 함수
        function toggleFileUpload() {
            const fileUploadArea = document.getElementById('file-upload-area');
            const isHidden = fileUploadArea.style.display === 'none' || fileUploadArea.style.display === '';
            
            if (isHidden) {
                fileUploadArea.style.display = 'block';
                fileUploadArea.scrollIntoView({ behavior: 'smooth' });
            } else {
                fileUploadArea.style.display = 'none';
            }
        }

        // 지원되는 파일 형식 가져오기
        async function getSupportedFormats() {
            try {
                const response = await fetch('/api/supported-formats');
                if (response.ok) {
                    const data = await response.json();
                    return data.formats;
                }
            } catch (error) {
                console.error('Error getting supported formats:', error);
            }
            return ['pdf', 'docx', 'doc', 'xlsx', 'xls', 'pptx', 'ppt', 'txt', 'jpg', 'jpeg', 'png', 'gif', 'bmp'];
        }

        // 파일 유효성 검사
        function validateFile(file) {
            const maxSize = 16 * 1024 * 1024; // 16MB
            const supportedTypes = [
                'application/pdf',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'application/msword',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                'application/vnd.ms-excel',
                'application/vnd.openxmlformats-officedocument.presentationml.presentation',
                'application/vnd.ms-powerpoint',
                'text/plain',
                'image/jpeg',
                'image/jpg',
                'image/png',
                'image/gif',
                'image/bmp'
            ];

            if (file.size > maxSize) {
                throw new Error('파일 크기가 16MB를 초과합니다.');
            }

            if (!supportedTypes.includes(file.type)) {
                throw new Error('지원되지 않는 파일 형식입니다.');
            }

            return true;
        }

        // 파일 업로드 처리
        async function handleFileUpload(file) {
            try {
                console.log('파일 업로드 시작:', file.name, file.type);
                
                validateFile(file);

                const formData = new FormData();
                formData.append('file', file);

                // 기존 결과 초기화
                const resultDiv = document.getElementById('analysis-result');
                resultDiv.style.display = 'none';
                resultDiv.innerHTML = '';

                // 업로드 진행률 표시
                const progressBar = document.getElementById('upload-progress');
                const progressFill = progressBar.querySelector('.progress-fill');
                const progressText = progressBar.querySelector('.progress-text');
                
                progressBar.style.display = 'block';
                progressFill.style.width = '0%';
                progressText.textContent = '업로드 중...';

                // 업로드 시작
                console.log('서버로 파일 전송 중...');
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                progressFill.style.width = '100%';
                progressText.textContent = 'AI 분석 중...';

                if (response.ok) {
                    const result = await response.json();
                    console.log('분석 결과 수신:', result);
                    
                    // 성공 메시지 표시
                    progressText.textContent = '분석 완료!';
                    
                    // 결과 표시 - 강제로 분석 결과만 표시
                    displayAnalysisResult(result);
                    
                    // 시스템 메시지 추가
                    addSystemMessage(`📄 파일 "${file.name}"을 성공적으로 분석했습니다. 이제 이 문서에 대해 질문해보세요!`);
                    
                    setTimeout(() => {
                        progressBar.style.display = 'none';
                    }, 2000);
                    
                } else {
                    const error = await response.json();
                    throw new Error(error.error || '업로드 중 오류가 발생했습니다.');
                }

            } catch (error) {
                console.error('File upload error:', error);
                document.getElementById('analysis-result').innerHTML = `
                    <div class="error-message">
                        <i class="fas fa-exclamation-circle"></i>
                        ${error.message}
                    </div>
                `;
                
                const progressBar = document.getElementById('upload-progress');
                progressBar.style.display = 'none';
            }
        }

        // 분석 결과 표시
        function displayAnalysisResult(result) {
            const resultDiv = document.getElementById('analysis-result');
            
            // 결과 표시 영역을 보이도록 설정
            resultDiv.style.display = 'block';
            
            // 키워드가 배열인지 확인하고 처리
            const keywords = Array.isArray(result.keywords) ? result.keywords : [];
            const keywordTags = keywords.length > 0 
                ? keywords.map(keyword => `<span class="keyword-tag">${keyword}</span>`).join('')
                : '<span class="keyword-tag">분석된 키워드 없음</span>';
            
            // 인사이트 처리
            const insights = Array.isArray(result.insights) ? result.insights : [];
            const insightsList = insights.length > 0
                ? insights.map(insight => `<li>${insight}</li>`).join('')
                : '<li>추가 인사이트를 생성 중입니다...</li>';
            
            resultDiv.innerHTML = `
                <div class="analysis-result">
                    <h4><i class="fas fa-file-alt"></i> 문서 분석 완료</h4>
                    <div class="file-info">
                        <strong>파일명:</strong> ${result.filename}<br>
                        <strong>형식:</strong> ${result.file_type}<br>
                        <strong>크기:</strong> ${(result.file_size / 1024).toFixed(1)} KB<br>
                        <strong>텍스트 길이:</strong> ${result.text_length} 글자<br>
                        <strong>분석 시간:</strong> ${(result.analysis_time || 0).toFixed(2)}초
                    </div>
                    <div class="analysis-summary">
                        <strong>🤖 AI 분석 요약:</strong>
                        <div class="analysis-content">
                            ${result.analysis ? result.analysis.replace(/\n/g, '<br>') : '문서를 성공적으로 분석했습니다.'}
                        </div>
                    </div>
                    <div class="keywords">
                        <strong>🎯 주요 키워드:</strong><br>
                        ${keywordTags}
                    </div>
                    <div class="insights">
                        <strong>💡 핵심 인사이트:</strong>
                        <ul>${insightsList}</ul>
                    </div>
                    ${result.expert_analysis && Object.keys(result.expert_analysis).length > 0 ? `
                    <div class="expert-analysis">
                        <strong>👨‍💼 전문가 분석:</strong>
                        <p>${Object.values(result.expert_analysis)[0] || '전문가 분석을 완료했습니다.'}</p>
                    </div>
                    ` : ''}
                </div>
            `;
            
            // 분석 완료 후 채팅으로 컨텍스트 전송
            if (result.analysis) {
                // 세션에 문서 컨텍스트 저장
                const documentContext = {
                    filename: result.filename,
                    file_type: result.file_type,
                    analysis: result.analysis,
                    keywords: result.keywords,
                    insights: result.insights,
                    timestamp: new Date().toISOString()
                };
                
                // SessionStorage에 문서 컨텍스트 저장
                const sessionKey = 'document_context';
                sessionStorage.setItem(sessionKey, JSON.stringify(documentContext));
                
                console.log('문서 컨텍스트가 세션에 저장되었습니다:', documentContext);
            }
        }

        // 드래그 앤 드롭 이벤트 핸들러
        function setupDragAndDrop() {
            const dropZone = document.getElementById('file-drop-zone');
            const fileInput = document.getElementById('file-input');
            
            if (!dropZone || !fileInput) {
                console.error('파일 업로드 요소를 찾을 수 없습니다.');
                return;
            }
            
            // 드롭존 클릭 시 파일 선택 대화상자 열기
            dropZone.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                fileInput.click();
            });
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            dropZone.addEventListener('drop', handleDrop, false);

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function highlight(e) {
                dropZone.classList.add('drag-over');
            }

            function unhighlight(e) {
                dropZone.classList.remove('drag-over');
            }

            function handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const dt = e.dataTransfer;
                const files = dt.files;

                if (files.length > 0) {
                    console.log('파일 드롭됨:', files[0].name, files[0].type);
                    handleFileUpload(files[0]);
                }
            }
        }

        // 별점 선택
        document.querySelectorAll('.star').forEach(star => {
            star.onclick = () => {
                const rating = parseInt(star.dataset.rating);
                selectedRating = rating;
                
                document.querySelectorAll('.star').forEach((s, index) => {
                    s.classList.toggle('active', index < rating);
                });
            };
        });

        // 피드백 제출
        function submitFeedback() {
            if (!currentConversationId || !lastMessageId || selectedRating === 0) {
                showToast('피드백을 제출하려면 대화와 별점이 필요합니다', 'error');
                return;
            }
            
            const goblinId = Array.from(selectedGoblins)[0];
            
            // socket.emit('feedback', {
            //     goblin_id: goblinId,
            //     conversation_id: currentConversationId,
            //     message_id: lastMessageId,
            //     rating: selectedRating,
            //     feedback_type: selectedRating >= 4 ? 'helpful' : 'negative',
            //     comment: ''
            // });
            
            // 피드백 시뮬레이션
            console.log('피드백 시뮬레이션:', {
                goblin_id: goblinId,
                rating: selectedRating
            });
            
            setTimeout(() => {
                handleFeedbackResult({
                    success: true,
                    rating: selectedRating
                });
            }, 500);
        }

        // 피드백 결과 처리
        function handleFeedbackResult(data) {
            if (data.success) {
                showToast(`피드백이 제출되었습니다! (${data.rating}⭐)`);
                
                // 별점 초기화
                selectedRating = 0;
                document.querySelectorAll('.star').forEach(s => s.classList.remove('active'));
                document.querySelector('.feedback-btn').disabled = true;
            } else {
                showToast(`피드백 제출 실패: ${data.error}`, 'error');
            }
        }

        // 성능 통계 업데이트
        function updatePerformanceStats(data) {
            try {
                // 안전한 요소 업데이트
                const totalGoblinsEl = document.getElementById('total-goblins');
                if (totalGoblinsEl && data.performance) {
                    totalGoblinsEl.textContent = data.performance.total_goblins || 39;
                }
                
                const activeUsersEl = document.getElementById('active-users');
                if (activeUsersEl) {
                    activeUsersEl.textContent = data.active_users || 0;
                }
                
                console.log('📊 성능 데이터 업데이트 완료:', data);
            } catch (error) {
                console.warn('⚠️ 성능 데이터 업데이트 실패:', error);
            }
        }

        // 토스트 알림 표시
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // 애니메이션
            setTimeout(() => toast.classList.add('show'), 100);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => document.body.removeChild(toast), 300);
            }, 3000);
        }

        // Enter 키로 메시지 전송
        document.getElementById('chat-input').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // 실제 1000자 고급 AI API 호출
        async function callAdvancedAI(message, goblinId) {
            try {
                // 세션 기반 conversation_id 가져오기
                const sessionConversationId = getSessionConversationId();
                
                const response = await fetch('/api/chat/advanced', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        goblin_id: parseInt(goblinId),
                        mode: currentMode,  // 모드 정보 추가
                        conversation_id: sessionConversationId  // 세션 ID 전송
                    })
                });

                const data = await response.json();
                
                if (data.status === 'success') {
                    console.log('🎉 1000자 AI 응답 생성 완료:', data.result.response_length + '자');
                    
                    handleChatResponse({
                        success: true,
                        result: {
                            response: data.result.response,
                            conversation_id: data.result.conversation_id,
                            goblin_id: goblinId,
                            expert_type: data.result.expert_type,
                            response_length: data.result.response_length,
                            timestamp: data.result.timestamp
                        }
                    });
                } else {
                    throw new Error(data.message || '알 수 없는 오류가 발생했습니다.');
                }
            } catch (error) {
                console.error('❌ 고급 AI 호출 실패:', error);
                
                // 실패 시 기존 시뮬레이션으로 폴백
                simulateAdvancedResponse(message, goblinId);
            }
        }

        // 고급 AI 시뮬레이션 함수들
        function simulateAdvancedResponse(message, goblinId) {
            // 고급 AI 분석 함수들
            const analyzeMessage = (msg) => {
                const emotions = {
                    curious: ['뭐예요', '머예요', '란?', '이란?', '뭔지', '알려주세요', '궁금', '?'],
                    excited: ['!', '와', '대박', '신기', '재미', '좋다', '멋지'],
                    confused: ['모르겠', '헷갈', '어려워', '복잡', '이해 안'],
                    urgent: ['빨리', '급하', '지금', '당장', '도와주세요'],
                    polite: ['부탁', '감사', '죄송', '실례', '정중']
                };
                
                let detectedEmotion = 'neutral';
                for (const [emotion, keywords] of Object.entries(emotions)) {
                    if (keywords.some(keyword => msg.includes(keyword))) {
                        detectedEmotion = emotion;
                        break;
                    }
                }
                
                const complexity = msg.length > 10 ? 'complex' : 'simple';
                const questionType = msg.includes('?') || msg.includes('란') || msg.includes('뭐') ? 'question' : 'statement';
                
                return { emotion: detectedEmotion, complexity, questionType };
            };

            const generateDetailedResponse = (msg, analysis, goblinId) => {
                // 도깨비별 전문 지식 기반 상세 응답
                const expertResponses = {
                    1: { // AI전문가
                        intro: "🤖 AI 전문가로서 분석해드리겠습니다.",
                        knowledge: {
                            "인공지능": `인공지능(Artificial Intelligence)은 인간의 지능을 기계로 구현하는 기술입니다.

📍 **핵심 구성요소:**
• 머신러닝(Machine Learning): 데이터로부터 패턴을 학습
• 딥러닝(Deep Learning): 신경망을 통한 복잡한 학습
• 자연어처리(NLP): 인간의 언어를 이해하고 생성
• 컴퓨터 비전: 이미지와 영상을 인식하고 분석

🔬 **현재 활용 분야:**
• 의료진단, 자율주행, 추천시스템, 번역서비스
• 음성인식, 이미지생성, 게임AI, 로봇공학

💡 **미래 전망:**
AGI(일반인공지능) 개발을 통해 인간과 같은 범용적 사고능력을 갖춘 AI가 등장할 것으로 예상됩니다.`,
                            "머신러닝": `머신러닝은 데이터를 통해 컴퓨터가 스스로 학습하는 AI의 핵심 기술입니다.

🎯 **학습 방식:**
• 지도학습: 정답이 있는 데이터로 학습
• 비지도학습: 패턴 발견을 통한 자율학습
• 강화학습: 시행착오를 통한 최적화 학습

⚙️ **주요 알고리즘:**
• 선형회귀, 의사결정트리, 랜덤포레스트
• SVM, 클러스터링, 신경망

📊 **활용 예시:**
스팸메일 필터링, 주식 예측, 고객 세분화, 추천시스템 등`
                        }
                    },
                    2: { // 데이터과학박사
                        intro: "📊 데이터 과학 관점에서 심층 분석해드리겠습니다.",
                        knowledge: {
                            "데이터": `데이터는 현대 디지털 사회의 가장 중요한 자원입니다.

📈 **데이터 유형:**
• 정형데이터: 표 형태의 구조화된 데이터
• 반정형데이터: XML, JSON 같은 반구조화 데이터  
• 비정형데이터: 텍스트, 이미지, 영상 등

🔍 **분석 프로세스:**
1. 수집(Collection) → 2. 정제(Cleaning) → 3. 탐색(EDA) 
4. 모델링(Modeling) → 5. 검증(Validation) → 6. 배포(Deploy)

💹 **비즈니스 가치:**
데이터 기반 의사결정으로 매출 15-20% 증가, 비용 10-15% 절감 효과가 입증되었습니다.`
                        }
                    }
                };

                const expert = expertResponses[goblinId];
                if (!expert) {
                    return `전문가로서 "${msg}"에 대해 자세히 설명드리겠습니다. 이는 매우 흥미로운 주제이며, 실무 경험을 바탕으로 단계별로 접근해보겠습니다.`;
                }

                // 키워드 매칭으로 전문 지식 찾기
                for (const [keyword, content] of Object.entries(expert.knowledge)) {
                    if (msg.includes(keyword)) {
                        return `${expert.intro}

${content}

💬 더 궁금한 점이 있으시면 언제든 말씀해주세요!`;
                    }
                }

                return `${expert.intro}

"${msg}"에 대해 더 구체적으로 질문해주시면 전문 지식을 바탕으로 상세히 설명드리겠습니다.`;
            };

            // 메시지 분석
            const analysis = analyzeMessage(message);
            console.log('📊 메시지 분석 결과:', analysis);

            // 감정에 따른 응답 조정
            let responsePrefix = '';
            switch(analysis.emotion) {
                case 'curious':
                    responsePrefix = '🤔 궁금증이 느껴지는 질문이네요! ';
                    break;
                case 'excited':
                    responsePrefix = '🎉 열정적인 에너지가 전해집니다! ';
                    break;
                case 'confused':
                    responsePrefix = '😊 복잡해 보이지만 차근차근 설명해드릴게요! ';
                    break;
                case 'urgent':
                    responsePrefix = '⚡ 급하신 것 같으니 핵심부터 말씀드리겠습니다! ';
                    break;
            }

            // 상세한 응답 생성
            const detailedResponse = generateDetailedResponse(message, analysis, goblinId);
            const finalResponse = responsePrefix + detailedResponse;

            handleChatResponse({
                success: true,
                result: {
                    response: finalResponse,
                    conversation_id: 'sim_' + Date.now(),
                    goblin_id: goblinId,
                    timestamp: new Date().toISOString(),
                    analysis: analysis
                }
            });
        }

        // 시뮬레이션 함수들
        function simulateResponse(message, goblinId) {
            // 도깨비별 개성 있는 응답
            const goblinResponses = {
                1: [ // AI전문가
                    `🤖 안녕하세요! AI 전문가입니다. "${message}"에 대해 데이터 기반으로 분석해드릴게요!`,
                    `💡 흥미로운 질문이네요! 머신러닝 관점에서 "${message}"를 살펴보겠습니다.`,
                    `🔍 "${message}"... 이건 알고리즘으로 최적화할 수 있을 것 같은데요?`,
                    `⚡ 혁신적인 아이디어군요! "${message}"를 AI 기술로 어떻게 해결할지 함께 고민해봐요.`
                ],
                2: [ // 데이터과학박사
                    `📊 안녕하세요! 데이터로 말하는 과학자입니다. "${message}" 데이터를 분석해볼까요?`,
                    `📈 통계적으로 봤을 때 "${message}"는 매우 흥미로운 패턴을 보이네요!`,
                    `🔢 "${message}"에 숨겨진 인사이트를 찾아보겠습니다. 수치로 증명해드릴게요!`,
                    `💹 빅데이터 분석 결과, "${message}"는 트렌드 상승 중입니다!`
                ],
                3: [ // 블록체인개발자
                    `⛓️ 블록체인 세계에 오신 걸 환영합니다! "${message}"를 탈중앙화로 해결해볼까요?`,
                    `💎 "${message}"... 이거 스마트 컨트랙트로 자동화하면 어떨까요?`,
                    `🚀 미래지향적 질문이네요! "${message}"를 Web3으로 혁신해보겠습니다.`,
                    `🔐 보안과 투명성이 핵심이죠. "${message}"를 블록체인으로 검증해드릴게요!`
                ],
                4: [ // 보안전문가
                    `🛡️ 보안 전문가입니다! "${message}"의 보안 취약점부터 점검해볼까요?`,
                    `🔒 "${message}"... 혹시 해킹 위험은 없는지 먼저 확인해봅시다!`,
                    `⚠️ 사이버 보안 관점에서 "${message}"는 신중하게 접근해야 할 것 같네요.`
                ],
                10: [ // 인공지능박사도깨비
                    `🎓 AI 박사입니다! "${message}"를 학술적으로 심층 분석해드리겠습니다!`,
                    `📚 연구 논문 기반으로 "${message}"에 대한 최신 이론을 설명해드릴게요!`,
                    `🧠 딥러닝 알고리즘으로 "${message}"를 모델링해볼까요?`
                ],
                11: [ // 경영학박사도깨비
                    `💼 경영 전략가입니다! "${message}"를 비즈니스 관점에서 분석해보겠습니다!`,
                    `📋 "${message}"... 이거 ROI 계산해보고 실행 계획 세워봅시다!`,
                    `🎯 리더십 경험으로 봤을 때, "${message}"는 전략적 접근이 필요하네요!`
                ],
                12: [ // 의학박사도깨비
                    `⚕️ 의학박사입니다! "${message}"와 관련된 건강 측면을 살펴보겠습니다!`,
                    `🩺 전문의 입장에서 "${message}"에 대한 의학적 조언을 드릴게요!`,
                    `💊 "${message}"... 예방이 치료보다 중요하다는 관점에서 접근해봅시다!`
                ],
                17: [ // 철학박사도깨비
                    `🤔 철학자의 관점에서 "${message}"의 본질을 탐구해보겠습니다...`,
                    `💭 "${message}"라는 것은 과연 무엇일까요? 함께 사색해봅시다.`,
                    `🌟 소크라테스가 "${message}"에 대해 뭐라고 했을까요? 철학적으로 접근해봅시다!`
                ]
            };

            // 기본 응답 (다른 도깨비들용)
            const defaultResponses = [
                `안녕하세요! 전문가 도깨비입니다. "${message}"에 대해 깊이 있게 답변드리겠습니다! 🧙‍♂️`,
                `흥미로운 주제네요! "${message}"는 제 전문 분야와 관련이 깊습니다. 자세히 설명해드릴게요! ✨`,
                `좋은 질문입니다! "${message}"에 대한 실무 경험을 바탕으로 조언드리겠습니다! 💫`,
                `"${message}"... 이거 정말 중요한 포인트를 짚으셨네요! 함께 분석해봅시다! 🎯`,
                `전문가로서 "${message}"에 대해 체계적으로 접근해보겠습니다! 🔍`,
                `"${message}"는 최근 핫한 이슈죠! 트렌드와 함께 설명드릴게요! 📈`
            ];

            // 특별한 인사말 처리
            const greetings = ['안녕하세요', '안녕', '하이', 'hi', 'hello', '헬로', '좋은 아침', '좋은 오후', '좋은 저녁'];
            const isGreeting = greetings.some(greeting => 
                message.toLowerCase().includes(greeting.toLowerCase())
            );

            let responses;
            if (isGreeting) {
                // 인사말에 대한 특별 응답
                const greetingResponses = [
                    `안녕하세요! 👋 저는 이 분야 전문가 도깨비입니다. 무엇을 도와드릴까요?`,
                    `반갑습니다! 😊 오늘은 어떤 궁금한 것이 있으신가요?`,
                    `안녕하세요! ✨ 전문가의 조언이 필요하시면 언제든 말씀해주세요!`,
                    `하이! 🌟 도깨비마을에 오신 걸 환영합니다! 무엇을 상담해드릴까요?`,
                    `좋은 하루예요! 😄 제 전문 지식으로 도움을 드릴 준비가 되어있습니다!`
                ];
                responses = greetingResponses;
            } else {
                responses = goblinResponses[goblinId] || defaultResponses;
            }
            const randomResponse = responses[Math.floor(Math.random() * responses.length)];
            
            handleChatResponse({
                success: true,
                result: {
                    response: randomResponse,
                    conversation_id: 'sim_' + Date.now(),
                    goblin_id: goblinId,
                    timestamp: new Date().toISOString()
                }
            });
        }

        function simulateTeamResponse(message, goblinIds) {
            const teamResponse = `팀 협업 답변: "${message}"에 대해 ${goblinIds.length}명의 전문가가 함께 답변드립니다. 다양한 관점에서 종합적인 솔루션을 제공하겠습니다.`;
            
            handleTeamResponse({
                success: true,
                responses: [{
                    goblin_id: goblinIds[0],
                    response: teamResponse,
                    timestamp: new Date().toISOString()
                }],
                team_summary: `${goblinIds.length}명 전문가 협업 완료`
            });
        }

        // 3D 아바타 시스템 변수
        let scene, camera, renderer, avatar, light;
        let currentEmotion = 'neutral';
        let isAvatarInitialized = false;
        
        // 얼굴 표정 요소들
        let leftEye, rightEye, mouth, leftPupil, rightPupil;
        
        // 감정 분석 및 아바타 시스템 함수들
        function analyzeKoreanEmotion(text) {
            if (!text) return { emotion: 'neutral', confidence: 0.5 };
            
            const emotionKeywords = {
                happy: ['기쁘', '기뻐', '행복', '좋', '웃', '즐거', '신나', '만족', '감사', '최고', '굿', '야호', '와우', '대박좋', '짱'],
                sad: ['슬프', '슬퍼', '우울', '힘들', '아프', '외로', '괴로', '절망', '실망', '눈물', '울어', '속상', '안타깝'],
                angry: ['화', '화나', '짜증', '분노', '열받', '빡쳐', '미쳐', '악', '싫어', '짜증나', '분해', '화났'],
                excited: ['신나', '흥분', '두근', '기대', '설레', '와', '오오', '대박', '완전', '쩔어'],
                thinking: ['생각', '고민', '음', '흠', '글쎄', '어떨까', '모르겠', '궁금', '한번'],
                surprise: ['놀라', '깜짝', '와', '어머', '헐', '대박', '진짜', '세상에', '어떻게', '믿을수없어'],
                fear: ['무서', '두려', '걱정', '불안', '떨려', '겁나', '조심', '위험', '아이고'],
                neutral: ['그냥', '보통', '별로', '음', '글쎄', '하지만', '그러나', '네', '아니요']
            };
            
            let maxScore = 0;
            let detectedEmotion = 'neutral';
            
            // 텍스트를 소문자로 변환하고 공백 제거
            const normalizedText = text.toLowerCase().replace(/\s/g, '');
            
            for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
                let score = 0;
                keywords.forEach(keyword => {
                    if (normalizedText.includes(keyword)) {
                        score += 2; // 점수를 2배로 증가
                    }
                    // 부분 매칭도 확인
                    if (text.includes(keyword.substring(0, 2)) && keyword.length > 2) {
                        score += 1;
                    }
                });
                
                if (score > maxScore) {
                    maxScore = score;
                    detectedEmotion = emotion;
                }
            }
            
            const confidence = Math.min(maxScore / 2, 1.0);
            return { emotion: detectedEmotion, confidence: confidence };
        }
        
        function createRealisticAvatar() {
            // 3D 씬 초기화
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, 400 / 500, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(400, 500);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            const avatarContainer = document.getElementById('avatar-container');
            if (avatarContainer) {
                avatarContainer.appendChild(renderer.domElement);
            }
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // 포인트 라이트 추가 (얼굴 조명)
            const pointLight = new THREE.PointLight(0xffffff, 0.6, 100);
            pointLight.position.set(0, 3, 3);
            scene.add(pointLight);
            
            // 리얼리스틱 아바타 생성
            const group = new THREE.Group();
            
            // 🎨 리얼리스틱 머티리얼
            const skinMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffdbac,
                transparent: true,
                opacity: 0.95
            });
            
            const hairMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8b4513,
                shininess: 20
            });
            
            const clothMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3498db
            });
            
            const eyeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                shininess: 100
            });
            
            // 👤 리얼리스틱 헤드 (더 정교한 형태)
            const headGroup = new THREE.Group();
            
            // 메인 헤드 (타원형)
            const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            headGeometry.scale(1, 1.1, 0.85);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.castShadow = true;
            head.receiveShadow = true;
            headGroup.add(head);
            
            // 목
            const neckGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.4);
            const neck = new THREE.Mesh(neckGeometry, skinMaterial);
            neck.position.set(0, -0.4, 0);
            neck.castShadow = true;
            headGroup.add(neck);
            
            // 더 사실적인 눈
            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            
            leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.18, 0.1, 0.42);
            headGroup.add(leftEye);
            
            rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.18, 0.1, 0.42);
            headGroup.add(rightEye);
            
            // 눈동자 하이라이트
            const pupilGeometry = new THREE.SphereGeometry(0.02, 8, 8);
            const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.16, 0.12, 0.48);
            headGroup.add(leftPupil);
            
            rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.20, 0.12, 0.48);
            headGroup.add(rightPupil);
            
            // 리얼리스틱 코
            const noseGeometry = new THREE.ConeGeometry(0.04, 0.12, 8);
            const nose = new THREE.Mesh(noseGeometry, skinMaterial);
            nose.position.set(0, 0, 0.45);
            nose.rotation.x = Math.PI;
            headGroup.add(nose);
            
            // 입
            const mouthGeometry = new THREE.SphereGeometry(0.06, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const mouthMaterial = new THREE.MeshLambertMaterial({ color: 0xff6b6b });
            mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, -0.1, 0.44);
            mouth.rotation.x = Math.PI;
            headGroup.add(mouth);
            
            // 더 자연스러운 머리카락
            const hairGeometry = new THREE.SphereGeometry(0.52, 24, 24);
            hairGeometry.scale(1, 1.2, 0.9);
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.set(0, 0.2, -0.1);
            hair.castShadow = true;
            headGroup.add(hair);
            
            headGroup.position.set(0, 2.4, 0);
            group.add(headGroup);
            
            // 🫵 리얼리스틱 몸통 (더 자연스러운 형태)
            const torsoGeometry = new THREE.CylinderGeometry(0.35, 0.45, 1.0);
            const torso = new THREE.Mesh(torsoGeometry, clothMaterial);
            torso.position.set(0, 1.5, 0);
            torso.castShadow = true;
            torso.receiveShadow = true;
            group.add(torso);
            
            // 가슴 부분 (더 자연스러운 체형)
            const chestGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            chestGeometry.scale(1, 0.6, 0.8);
            const chest = new THREE.Mesh(chestGeometry, clothMaterial);
            chest.position.set(0, 1.8, 0);
            chest.castShadow = true;
            group.add(chest);
            
            // 🦾 간단하고 자연스러운 팔
            const armGeometry = new THREE.CylinderGeometry(0.07, 0.05, 1.2);
            
            // 왼쪽 팔
            const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
            leftArm.position.set(-0.45, 1.4, 0);
            leftArm.rotation.z = -0.4;
            leftArm.castShadow = true;
            group.add(leftArm);
            
            // 오른쪽 팔
            const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
            rightArm.position.set(0.45, 1.4, 0);
            rightArm.rotation.z = 0.4;
            rightArm.castShadow = true;
            group.add(rightArm);
            
            // 손
            const handGeometry = new THREE.SphereGeometry(0.08, 12, 12);
            handGeometry.scale(1.3, 1, 0.8);
            
            const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
            leftHand.position.set(-0.2, 0.8, 0);
            leftHand.castShadow = true;
            group.add(leftHand);
            
            const rightHand = new THREE.Mesh(handGeometry, skinMaterial);
            rightHand.position.set(0.2, 0.8, 0);
            rightHand.castShadow = true;
            group.add(rightHand);
            
            // 🦵 리얼리스틱 다리
            const pantsMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
            
            // 허리
            const waistGeometry = new THREE.CylinderGeometry(0.4, 0.35, 0.3);
            const waist = new THREE.Mesh(waistGeometry, pantsMaterial);
            waist.position.set(0, 0.85, 0);
            waist.castShadow = true;
            group.add(waist);
            
            // 왼쪽 다리
            const leftThighGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.8);
            const leftThigh = new THREE.Mesh(leftThighGeometry, pantsMaterial);
            leftThigh.position.set(-0.15, 0.3, 0);
            leftThigh.castShadow = true;
            group.add(leftThigh);
            
            const leftShinGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.7);
            const leftShin = new THREE.Mesh(leftShinGeometry, pantsMaterial);
            leftShin.position.set(-0.15, -0.55, 0);
            leftShin.castShadow = true;
            group.add(leftShin);
            
            // 오른쪽 다리
            const rightThighGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.8);
            const rightThigh = new THREE.Mesh(rightThighGeometry, pantsMaterial);
            rightThigh.position.set(0.15, 0.3, 0);
            rightThigh.castShadow = true;
            group.add(rightThigh);
            
            const rightShinGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.7);
            const rightShin = new THREE.Mesh(rightShinGeometry, pantsMaterial);
            rightShin.position.set(0.15, -0.55, 0);
            rightShin.castShadow = true;
            group.add(rightShin);
            
            // 👟 신발
            const shoeGeometry = new THREE.BoxGeometry(0.15, 0.08, 0.3);
            const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
            
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-0.15, -0.95, 0.1);
            leftShoe.castShadow = true;
            group.add(leftShoe);
            
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0.15, -0.95, 0.1);
            rightShoe.castShadow = true;
            group.add(rightShoe);
            
            // 아바타 그룹을 scene에 추가
            avatar = group;
            scene.add(avatar);
            
            // 카메라 위치 설정 (아바타가 잘 보이도록)
            camera.position.set(0, 1.5, 4);
            camera.lookAt(0, 1.5, 0);
            
            // 애니메이션 시작
            animate();
            isAvatarInitialized = true;
            
            console.log('🎯 리얼리스틱 3D 아바타 초기화 완료');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (avatar) {
                // 기본 호흡 애니메이션
                avatar.position.y = Math.sin(Date.now() * 0.002) * 0.05;
                
                // 감정에 따른 고급 애니메이션
                switch(currentEmotion) {
                    case 'happy':
                        // 즐거운 좌우 흔들림 + 점프
                        avatar.rotation.z = Math.sin(Date.now() * 0.008) * 0.15;
                        avatar.position.y += Math.sin(Date.now() * 0.01) * 0.1;
                        break;
                        
                    case 'sad':
                        // 슬픈 고개 숙임 + 느린 움직임
                        avatar.rotation.x = -0.3 + Math.sin(Date.now() * 0.002) * 0.05;
                        avatar.position.y -= 0.1;
                        break;
                        
                    case 'angry':
                        // 화난 좌우 격렬한 흔들림 + 떨림
                        avatar.rotation.y = Math.sin(Date.now() * 0.02) * 0.3;
                        avatar.rotation.z = Math.sin(Date.now() * 0.025) * 0.1;
                        break;
                        
                    case 'excited':
                        // 흥분한 크기 변화 + 빠른 회전
                        avatar.scale.setScalar(1 + Math.sin(Date.now() * 0.015) * 0.15);
                        avatar.rotation.y = Math.sin(Date.now() * 0.01) * 0.2;
                        break;
                        
                    case 'thinking':
                        // 생각하는 천천히 고개 끄덕임 + 좌우 살펴보기
                        avatar.rotation.x = Math.sin(Date.now() * 0.003) * 0.1;
                        avatar.rotation.y = Math.sin(Date.now() * 0.002) * 0.2;
                        break;
                        
                    case 'surprise':
                        // 놀란 갑작스러운 뒤로 젖힘 + 크기 변화
                        avatar.rotation.x = 0.2 + Math.sin(Date.now() * 0.02) * 0.1;
                        avatar.scale.setScalar(1 + Math.sin(Date.now() * 0.03) * 0.2);
                        break;
                        
                    case 'fear':
                        // 두려운 떨림 + 움츠러듦
                        avatar.rotation.x = Math.sin(Date.now() * 0.05) * 0.05;
                        avatar.rotation.z = Math.sin(Date.now() * 0.07) * 0.05;
                        avatar.scale.setScalar(0.95 + Math.sin(Date.now() * 0.04) * 0.05);
                        break;
                        
                    case 'neutral':
                    default:
                        // 기본 상태로 부드럽게 복귀
                        avatar.rotation.x = avatar.rotation.x * 0.95;
                        avatar.rotation.y = avatar.rotation.y * 0.95;
                        avatar.rotation.z = avatar.rotation.z * 0.95;
                        avatar.scale.setScalar(avatar.scale.x * 0.99 + 0.01);
                        break;
                }
                
                // 옷 색상 변경 (감정에 따라)
                if (avatar.children && avatar.children.length > 0) {
                    updateAvatarColors(currentEmotion);
                }
            }
            
            if (renderer) {
                renderer.render(scene, camera);
            }
        }
        
        function updateAvatarColors(emotion) {
            // 감정별 색상 설정
            const emotionColors = {
                'happy': { cloth: 0x3498db, intensity: 1.2 },      // 밝은 파랑
                'sad': { cloth: 0x7f8c8d, intensity: 0.6 },        // 회색
                'angry': { cloth: 0xe74c3c, intensity: 1.5 },      // 빨강
                'excited': { cloth: 0xf39c12, intensity: 1.4 },    // 주황
                'thinking': { cloth: 0x9b59b6, intensity: 1.0 },   // 보라
                'surprise': { cloth: 0xf1c40f, intensity: 1.3 },   // 노랑
                'fear': { cloth: 0x34495e, intensity: 0.7 },       // 어두운 회색
                'neutral': { cloth: 0x3498db, intensity: 1.0 }     // 기본 파랑
            };
            
            const config = emotionColors[emotion] || emotionColors.neutral;
            
            // 옷 색상 변경 (torso, chest 찾아서 변경)
            avatar.traverse(function(child) {
                if (child.isMesh && child.material) {
                    if (child.material.color && 
                        (child.material.color.getHex() === 0x3498db || 
                         child.material.color.getHex() === 0xe74c3c || 
                         child.material.color.getHex() === 0xf39c12 ||
                         child.material.color.getHex() === 0x7f8c8d ||
                         child.material.color.getHex() === 0x9b59b6 ||
                         child.material.color.getHex() === 0xf1c40f ||
                         child.material.color.getHex() === 0x34495e)) {
                        child.material.color.setHex(config.cloth);
                    }
                }
            });
        }
        
        function updateFacialExpression(emotion) {
            if (!leftEye || !rightEye || !mouth) return;
            
            // 감정별 표정 설정
            switch(emotion) {
                case 'happy':
                    // 웃는 표정: 눈 작아지고 입 위로
                    leftEye.scale.set(1, 0.6, 1);
                    rightEye.scale.set(1, 0.6, 1);
                    mouth.position.y = -0.05;
                    mouth.scale.set(1.3, 0.8, 1);
                    mouth.material.color.setHex(0xff8a95);
                    break;
                    
                case 'sad':
                    // 슬픈 표정: 눈 처지고 입 아래로
                    leftEye.scale.set(1, 1.2, 1);
                    rightEye.scale.set(1, 1.2, 1);
                    leftEye.rotation.z = 0.2;
                    rightEye.rotation.z = -0.2;
                    mouth.position.y = -0.15;
                    mouth.scale.set(0.8, 1.2, 1);
                    mouth.material.color.setHex(0x8b7d7d);
                    break;
                    
                case 'angry':
                    // 화난 표정: 눈 찡그리고 입 일그러짐
                    leftEye.scale.set(0.8, 1.3, 1);
                    rightEye.scale.set(0.8, 1.3, 1);
                    leftEye.rotation.z = -0.3;
                    rightEye.rotation.z = 0.3;
                    mouth.position.y = -0.12;
                    mouth.scale.set(0.6, 1.5, 1);
                    mouth.material.color.setHex(0xcc4444);
                    break;
                    
                case 'excited':
                    // 흥분한 표정: 눈 크고 입 벌어짐
                    leftEye.scale.set(1.4, 1.4, 1.4);
                    rightEye.scale.set(1.4, 1.4, 1.4);
                    mouth.position.y = -0.08;
                    mouth.scale.set(1.6, 1.6, 1.6);
                    mouth.material.color.setHex(0xff5566);
                    break;
                    
                case 'thinking':
                    // 생각하는 표정: 한쪽 눈 찡그림
                    leftEye.scale.set(0.7, 1, 1);
                    rightEye.scale.set(1.2, 1, 1);
                    mouth.position.y = -0.1;
                    mouth.scale.set(0.9, 0.9, 1);
                    mouth.material.color.setHex(0xaa6666);
                    break;
                    
                case 'surprise':
                    // 놀란 표정: 눈과 입 크게 벌어짐
                    leftEye.scale.set(1.6, 1.8, 1.6);
                    rightEye.scale.set(1.6, 1.8, 1.6);
                    mouth.position.y = -0.05;
                    mouth.scale.set(1.8, 2.0, 1.8);
                    mouth.material.color.setHex(0xff4455);
                    break;
                    
                case 'fear':
                    // 두려운 표정: 눈 크고 입 작아짐
                    leftEye.scale.set(1.3, 1.5, 1.3);
                    rightEye.scale.set(1.3, 1.5, 1.3);
                    mouth.position.y = -0.13;
                    mouth.scale.set(0.5, 0.8, 1);
                    mouth.material.color.setHex(0x996666);
                    break;
                    
                case 'neutral':
                default:
                    // 기본 표정으로 복원
                    leftEye.scale.set(1, 1, 1);
                    rightEye.scale.set(1, 1, 1);
                    leftEye.rotation.z = 0;
                    rightEye.rotation.z = 0;
                    mouth.position.y = -0.1;
                    mouth.scale.set(1, 1, 1);
                    mouth.material.color.setHex(0xff6b6b);
                    break;
            }
        }
        
        function updateAvatarEmotion(emotion) {
            currentEmotion = emotion;
            
            console.log(`🎭 아바타 감정 변경: ${emotion}`);
            
            // 즉시 색상 변경
            if (avatar) {
                updateAvatarColors(emotion);
            }
            
            // 표정 변화 적용
            updateFacialExpression(emotion);
            
            // 감정 표시 업데이트
            const emotionDisplay = document.getElementById('current-emotion');
            if (emotionDisplay) {
                emotionDisplay.textContent = getEmotionKorean(emotion);
            }
            
            // 감정 통계 업데이트
            updateEmotionStats(emotion);
        }
        
        function getEmotionKorean(emotion) {
            const emotionMap = {
                'happy': '😊 기쁨',
                'sad': '😢 슬픔',
                'angry': '😠 화남',
                'excited': '🤩 흥분',
                'thinking': '🤔 생각',
                'surprise': '😮 놀람',
                'fear': '😨 두려움',
                'neutral': '😐 평온'
            };
            return emotionMap[emotion] || '😐 평온';
        }
        
        function updateEmotionStats(emotion) {
            const statsElement = document.getElementById('emotion-stats');
            if (!statsElement) return;
            
            // 간단한 통계 업데이트 (실제로는 서버에서 데이터를 가져와야 함)
            const stats = {
                'happy': Math.floor(Math.random() * 50) + 20,
                'sad': Math.floor(Math.random() * 30) + 10,
                'angry': Math.floor(Math.random() * 20) + 5,
                'surprise': Math.floor(Math.random() * 25) + 10,
                'fear': Math.floor(Math.random() * 15) + 5,
                'neutral': Math.floor(Math.random() * 40) + 30
            };
            
            let statsHtml = '';
            for (const [key, value] of Object.entries(stats)) {
                const korean = getEmotionKorean(key);
                statsHtml += `<div class="stat-item">
                    <span>${korean}</span>
                    <span>${value}%</span>
                </div>`;
            }
            
            statsElement.innerHTML = statsHtml;
        }
        
        // 아바타 채팅 기능
        function sendAvatarMessage() {
            const input = document.getElementById('avatar-chat-input');
            const messages = document.getElementById('avatar-messages');
            
            if (!input || !messages) return;
            
            const message = input.value.trim();
            if (!message) return;
            
            // 사용자 메시지 추가
            const userMessage = document.createElement('div');
            userMessage.className = 'message user-message';
            userMessage.textContent = message;
            messages.appendChild(userMessage);
            
            // 감정 분석
            const emotionResult = analyzeKoreanEmotion(message);
            updateAvatarEmotion(emotionResult.emotion);
            
            // 특별한 질문 패턴 감지
            const specialQuestions = {
                '도깨비': [
                    '🧚‍♂️ 아하! 도깨비들과 비교하시는군요!\n\n' +
                    '👥 **전문가 도깨비들의 특징:**\n' +
                    '• 각각 전문 분야의 깊은 지식 보유\n' +
                    '• 16명이 협업해서 종합적 답변 제공\n' +
                    '• 실무 경험 기반의 실용적 조언\n\n' +
                    '🤖 **저 (3D 아바타)의 특징:**\n' +
                    '• 실시간 감정 인식 및 표현\n' +
                    '• 시각적 피드백으로 더 친근한 소통\n' +
                    '• 감정 상태에 따른 맞춤 응답\n\n' +
                    '🎯 **결론:** 도깨비들이 전문 지식을, 제가 감정적 교감을 담당해요! 완벽한 조합이죠! 😊',
                    
                    '😄 도깨비들 VS 저의 대결이네요!\n\n' +
                    '🏆 **도깨비들의 강점:**\n' +
                    '• 인공지능박사, 의학박사, 경영학박사 등 전문성 끝판왕\n' +
                    '• 1000자 고급 분석으로 깊이 있는 답변\n' +
                    '• 실제 업계 경험 바탕의 실무 팁\n\n' +
                    '💖 **제 강점:**\n' +
                    '• 표정 변화로 감정 표현 (도깨비들은 텍스트만!)\n' +
                    '• 실시간 반응으로 즉각적 소통\n' +
                    '• 3D 비주얼로 더 생생한 상호작용\n\n' +
                    '🤝 **최종 결론:** 도깨비들이 머리, 제가 마음을 담당하는 드림팀이에요!',
                    
                    '🎭 재미있는 비교네요!\n\n' +
                    '👑 **도깨비 전문가들:**\n' +
                    '• 각자 20년+ 경력의 베테랑\n' +
                    '• 논리적이고 체계적인 분석 제공\n' +
                    '• 전문 용어와 상세한 설명 특화\n\n' +
                    '🌟 **3D 아바타 저:**\n' +
                    '• 감정을 읽고 공감하는 능력\n' +
                    '• 친근하고 접근하기 쉬운 대화\n' +
                    '• 시각적 재미와 감정적 위로 제공\n\n' +
                    '✨ **궁극의 조합:** 도깨비들에게 전문 상담을, 저에게는 감정적 힐링을 받으세요! 😊'
                ]
            };
            
            // 특별 응답 확인
            let specialResponse = null;
            for (const [keyword, responses] of Object.entries(specialQuestions)) {
                if (message.includes(keyword)) {
                    specialResponse = responses[Math.floor(Math.random() * responses.length)];
                    break;
                }
            }
            
            // 감정별 맞춤 응답
            const emotionResponses = {
                'happy': [
                    '정말 기쁘시겠어요! 😊\n저도 덩달아 기분이 좋아져요!',
                    '와! 행복한 기분이 전해져요! 🎉\n좋은 하루 보내세요!',
                    '좋은 일이 있으셨나봐요!\n축하드려요! ✨'
                ],
                'sad': [
                    '힘든 시간이시군요... 😢\n괜찮아질 거예요.\n제가 곁에 있을게요.',
                    '슬프시겠어요.\n모든 게 다 지나갈 거예요.\n힘내세요! 💙',
                    '어려운 상황이시군요.\n천천히 이겨내봐요.\n응원할게요! 🤗'
                ],
                'angry': [
                    '화가 많이 나셨나봐요 😠\n잠시 심호흡해보세요.\n진정하시면 더 좋은 해결책이 보일 거예요.',
                    '스트레스 받으셨군요.\n조금 진정해보실까요?\n이야기하면 시원해질 거예요.',
                    '힘든 상황이시겠네요.\n화내실 만하군요.\n제가 들어드릴게요.'
                ],
                'excited': [
                    '와! 정말 신나시는군요! 🤩\n저도 기대돼요!\n더 자세히 들려주세요!',
                    '흥미진진하네요!\n에너지가 넘치시네요!\n멋져요! ⚡',
                    '정말 신이 나셨나봐요!\n저도 덩달아 신나요!\n계속 말씀해주세요! 🎉'
                ],
                'thinking': [
                    '깊이 생각하고 계시는군요 🤔\n천천히 생각해보세요.\n좋은 아이디어가 떠오를 거예요.',
                    '고민이 있으시군요.\n함께 생각해볼까요?\n두 명이 생각하면 더 좋은 답이 나올 거예요.',
                    '어려운 문제인가봐요.\n고민을 나누시면\n해결책이 보일 거예요.'
                ],
                'surprise': [
                    '정말 놀라우셨겠어요! 😮\n어떤 일인지 궁금해요!\n더 자세히 말씀해주세요!',
                    '깜짝 놀라셨군요!\n대단한 일이 있었나봐요!\n와! 믿을 수 없어요! 🌟',
                    '정말 예상치 못한 일이셨나봐요!\n놀라움이 전해져요!\n어떤 일인지 들려주세요!'
                ],
                'fear': [
                    '무서우셨겠어요 😨\n괜찮아요, 안전할 거예요.\n제가 함께 있을게요.',
                    '걱정이 많으시군요.\n차근차근 해결해봐요.\n모든 게 잘 될 거예요.',
                    '불안하시겠지만\n너무 걱정하지 마세요.\n함께 이겨내봐요! 🤗'
                ],
                'neutral': [
                    '말씀해주세요.\n어떻게 도와드릴까요? 😊\n궁금한 것이 있으시면 언제든 물어보세요!',
                    '네, 잘 들었어요.\n더 이야기해주세요.\n편하게 말씀하세요.',
                    '그렇군요.\n더 궁금한 것이 있으시면\n언제든 말씀해주세요!'
                ]
            };
            
            // 아바타 응답
            setTimeout(() => {
                let finalResponse;
                
                if (specialResponse) {
                    finalResponse = specialResponse;
                } else {
                    const responses = emotionResponses[emotionResult.emotion] || emotionResponses['neutral'];
                    finalResponse = responses[Math.floor(Math.random() * responses.length)];
                }
                
                const avatarMessage = document.createElement('div');
                avatarMessage.className = 'message avatar-message';
                avatarMessage.textContent = finalResponse;
                messages.appendChild(avatarMessage);
                
                // 스크롤 하단으로
                messages.scrollTop = messages.scrollHeight;
                
                console.log(`🎭 감정 분석: ${emotionResult.emotion} (신뢰도: ${emotionResult.confidence.toFixed(2)})`);
            }, 800);
            
            input.value = '';
            messages.scrollTop = messages.scrollHeight;
        }
        
        // 엔터키로 메시지 전송
        function handleAvatarKeyPress(event) {
            if (event.key === 'Enter') {
                sendAvatarMessage();
            }
        }
        
        // 감정 버튼 클릭 핸들러
        function setAvatarEmotion(emotion) {
            updateAvatarEmotion(emotion);
        }

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            initSocket();
            loadGoblins();
            
            // 파일 업로드 기능 초기화
            setupDragAndDrop();
            
            // 파일 입력 이벤트 설정
            const fileInput = document.getElementById('file-input');
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (e.target.files.length > 0) {
                        const file = e.target.files[0];
                        console.log('파일 선택됨:', file.name, file.type);
                        
                        // 파일을 분석하고 결과만 표시 (열지 않음)
                        handleFileUpload(file);
                        
                        // 파일 입력 초기화 (같은 파일을 다시 선택할 수 있도록)
                        e.target.value = '';
                    }
                });
            }
            
            // 3D 아바타 초기화
            setTimeout(() => {
                if (document.getElementById('avatar-container')) {
                    createRealisticAvatar();
                    updateEmotionStats('neutral');
                }
            }, 1000);
            
            // 주기적으로 성능 데이터 요청
            setInterval(async () => {
                try {
                    const response = await fetch('/api/performance');
                    const data = await response.json();
                    if (data.status === 'success') {
                        updatePerformanceStats({
                            performance: data.data,
                            active_users: data.data.active_users
                        });
                    }
                } catch (error) {
                    console.error('성능 데이터 로드 오류:', error);
                }
            }, 30000); // 30초마다
        });
    </script>
</body>
</html>
